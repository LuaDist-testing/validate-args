<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>validate.args</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:none" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Validating-Function-Arguments">Validating Function Arguments</a></li>
      <li><a href="#Validating-Data-Structures">Validating Data Structures</a></li>
      <li><a href="#Validation-Specifications">Validation Specifications</a></li>
      <li><a href="#Element-Types">Element Types</a></li>
      <li><a href="#Callback-Arguments">Callback Arguments</a></li>
      <li><a href="#Catch-all-Specifications">Catch-all Specifications</a></li>
      <li><a href="#Mutating-Validation-Specifications">Mutating Validation Specifications</a></li>
      <li><a href="#Element-Groups">Element Groups</a></li>
      <li><a href="#Validation-Options">Validation Options</a></li>
      <li><a href="#Object-oriented-interface">Object oriented interface</a>
        <ul>
          <li><a href="#Constructors">Constructors</a></li>
          <li><a href="#Methods">Methods</a></li>
        </ul>
      </li>
      <li><a href="#Procedural-interface">Procedural interface</a></li>
    </ul>
  </li>
  <li><a href="#EXAMPLES">EXAMPLES</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>validate.args - validate arguments and data structures</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  va = require(&#39;validate.args&#39;)

  -- set some options which will affect
  -- all procedural calls
  va.opts{ options }

  -- Procedural interface

  -- foo( a, b )
  func foo( ... )
    local spec = { &lt;specifications&gt; }
    local ok, a, b = va.validate( spec, ... )
  end

  -- goo( c, d )
  func goo( ... )
    local spec = { &lt;specifications&gt; }
    local ok, c, d = va.validate( options, spec, ... )
  end

  -- Object based interface
  func foo( ... )
    local spec = { &lt;specifications&gt; }
    local vo = va:new()
    vo:setopts{ ... }
    local ok, a, b = vo:validate( spec, ... )
  end</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p><b>validate.args</b> provides a framework for validating function arguments and data structures. Scalar and (nested) table values as well as lists of values of the same type may be validated.</p>

<p><b>validate.args</b> provides both procedural and object-oriented interfaces. The significant difference between the interfaces is that the procedural interface may be influenced by global settings while the object-oriented interface keeps those settings local to each object. Objects may themselves be cloned, allowing for nested hierarchies of validation specifications. Changes to parent objects do not affect child objects, and vice-versa.</p>

<h2 id="Validating-Function-Arguments">Validating Function Arguments</h2>

<p>Positional, named, and mixed positional and named arguments are supported. Positional arguments may be converted to named arguments for uniformity of access (see <a href="#Validation-Options">&quot;Validation Options&quot;</a>).</p>

<dl>

<dt id="Positional-arguments">Positional arguments</dt>
<dd>

<pre><code>  foo( 3, &#39;n&#39; )</code></pre>

<p>Positional arguments are not explicitly named when passed to the function. Their validation specifications are passed as a list, one element per argument:</p>

<pre><code>  { { pos1 specification },
    { pos2 specification }
  }</code></pre>

</dd>
<dt id="Named-arguments">Named arguments</dt>
<dd>

<pre><code>  goo{ a = 3, b = &#39;n&#39; }</code></pre>

<p>Named arguments are passed as a single table to the function (notice the <code>{}</code> syntactic sugar in the function invocation). Their validation specifications are passed as a table:</p>

<pre><code> { arg1_name = { arg1 specification },
   arg2_name = { arg2 specification }
 }</code></pre>

</dd>
<dt id="mixed-mode">&quot;mixed&quot; mode</dt>
<dd>

<pre><code>  bar( 3, &#39;n&#39;, { c = 22 } )</code></pre>

<p>Here a nested table is used to hold the named arguments. The table is simply another positional argument, so the validation specifications are passed as a list, one per argument:</p>

<pre><code>  { { pos1 specification },
    { pos2 specification },
    { table specification }
  }</code></pre>

<p>The validation specification for the table specifies the constraints on the named arguments, typically using the <code>vtable</code> constraint.</p>

</dd>
</dl>

<h2 id="Validating-Data-Structures">Validating Data Structures</h2>

<p>Validation of data structures is very similar to validating function arguments. The base structure operated upon is a table whose elements may be positional (indexed with integers) or named (indexed with anything else) or both. The layout of the validation specifications are identical to those described above. Typically the <b>validate_tbl</b> method or function is used.</p>

<h2 id="Validation-Specifications">Validation Specifications</h2>

<p>A validation specification is a set of constraints which a value must meet. In most cases the specification is encoded in a table, where each key-value pair represents a type of constraint and its parameters. The specification may also be specified by a function (see <a href="#Mutating-Validation-Specifications">&quot;Mutating Validation Specifications&quot;</a>).</p>

<p><b>Note:</b> The documentation below refers to validation of both function arguments and data structures. When the term <i>element</i> is used it refers to either a function argument or to an element of a data structure.</p>

<p>Multiple constraints may be specified for each element. There are no guarantees as to the order in which the constraints are applied.</p>

<p>The caller may provide constraints which modify the passed elements; these must not expect a particular sequence of operation.</p>

<p>The caller may provide callbacks which are called pre- and post- validation. These may modify the elements.</p>

<p>The following specification parameters are recognized:</p>

<dl>

<dt id="optional">optional</dt>
<dd>

<p>This is a boolean attribute which, if true, indicates that the element need not be present. Positional (as well as named elements) may be optional; if they are not at the end of the list they must be specified as <code>nil</code> in the list of input values, e.g.</p>

<pre><code>  nil, 3</code></pre>

<p>This defaults to <code>false</code>. All elements are required by default.</p>

</dd>
<dt id="default">default</dt>
<dd>

<p>This provides the default value when a element was not specified, as well as indicating that the element is optional. This may be a function, which will be called if a default value is required. The function is passed a single argument, a table (see <a href="#Callback-Arguments">&quot;Callback Arguments&quot;</a> for its contents). The function should return two values:</p>

<ol>

<li><p>a boolean indicating success or failure;</p>

</li>
<li><p>the default value upon success, an error message upon failure</p>

</li>
</ol>

<p>If no default value is specified for a table element with a vtable constraint, the nested specifications in the vtable are scanned for defaults.</p>

<p>Note that if nested specifications are scanned for defaults and not all of those specificatons provide defaults, an error will be thrown. To avoid this, use <code>default_is_nil</code></p>

</dd>
<dt id="default_is_nil">default_is_nil</dt>
<dd>

<p>This indicates that the default value for an element is <code>nil</code>. This is primarily used to indicate that nested vtable specifications should not be scanned for defaults.</p>

</dd>
<dt id="type">type</dt>
<dd>

<p>This specifies the expected type of the element. It may be either a single type or a list of types. See <a href="#Element-Types">&quot;Element Types&quot;</a> for more information. This is optional.</p>

</dd>
<dt id="enum">enum</dt>
<dd>

<p>This specifies one or more explicit values which the element may take. It may be either a single value or a list of values:</p>

<pre><code>  enum = 33
  enum = { &#39;a&#39;, 33, &#39;b&#39; }</code></pre>

</dd>
<dt id="allow_nil">allow_nil</dt>
<dd>

<p>This is a boolean and indicates that the element may be nil. This only pertains to positional elements.</p>

</dd>
<dt id="not_nil">not_nil</dt>
<dd>

<p>This is a boolean and indicates that the element must not be nil. This only pertains to positional elements. <i>THIS IS DEPRECATED</i>. It defaults to <code>true</code>.</p>

</dd>
<dt id="requires">requires</dt>
<dd>

<p>This lists the names of one or more elements which <i>must</i> be specified in addition to the current element. The value is either a single name or a list of names:</p>

<pre><code>  requires = &#39;arg3&#39;
  requires = { &#39;arg3&#39;, &#39;arg4&#39; }</code></pre>

<p>See also <a href="#Element-Groups">&quot;Element Groups&quot;</a></p>

</dd>
<dt id="excludes">excludes</dt>
<dd>

<p>This lists the names of one or more elements which <i>may not</i> be specified in addition to the current element. The value is either a single name or a list of names:</p>

<pre><code>  excludes = &#39;arg3&#39;
  excludes = { &#39;arg3&#39;, &#39;arg4&#39; }</code></pre>

<p>See also <a href="#Element-Groups">&quot;Element Groups&quot;</a></p>

</dd>
<dt id="one_of">one_of</dt>
<dd>

<p>This provides a list of names of other elements of which exactly one <i>must</i> be specified in addition to the current element:</p>

<pre><code>  one_of = { &#39;arg3&#39;, &#39;arg4&#39; }</code></pre>

<p>See also <a href="#Element-Groups">&quot;Element Groups&quot;</a></p>

</dd>
<dt id="vfunc">vfunc</dt>
<dd>

<p>This specifies a function which is called to validate the element. It is called with two arguments, the passed element value and a table (see <a href="#Callback-Arguments">&quot;Callback Arguments&quot;</a> for its contents). It must return two values:</p>

<ol>

<li><p>a boolean indicating success or failure;</p>

</li>
<li><p>the (possibly modified) element value upon success, an error message upon failure</p>

</li>
</ol>

<p>For example,</p>

<pre><code>  vfunc = function( orig )
            if type(orig) == &#39;number&#39; and orig &gt;= 3 then
              return true, orig / 22
            end
              return false, &#39;not a number or less then 3&#39;
          end</code></pre>

</dd>
<dt id="vtable">vtable</dt>
<dd>

<p>This is used to validate the contents of an element which is a table. Its value may be either:</p>

<dl>

<dt id="a-table-of-specifications">a table of specifications</dt>
<dd>

<p>There should be one element in the specification table for each element in the element table. For example, to validate a call such as</p>

<pre><code>  foo( &#39;hello&#39;, { nv1 = 3, nv2 = 2 } )</code></pre>

<p>Use</p>

<pre><code>  spec = { { type = &#39;string&#39; },
           { vtable = { nv1 = { type = &#39;posint&#39; },
                        nv2 = { type = &#39;int&#39; },
                      }
           }
         }
  ok, pos, tbl = validate( spec, ... )</code></pre>

<p>which will return</p>

<pre><code>   pos = &#39;hello&#39;
   tbl = { nv1 = 3, nv2 = 2 }

 in the above invocation.</code></pre>

</dd>
<dt id="a-function">a function</dt>
<dd>

<p>The function is called with two arguments: the passed element value, and a table (see <a href="#Callback-Arguments">&quot;Callback Arguments&quot;</a> for its contents) and must return two values:</p>

<ol>

<li><p>a boolean indicating success or failure;</p>

</li>
<li><p>Upon success, a table of validation specifications. Upon failure, an error message. See <a href="#EXAMPLES">&quot;EXAMPLES&quot;</a> for an example of this in use.</p>

</li>
</ol>

<p>This function may be called with the element value equal to <code>nil</code> if no element value was specified.</p>

</dd>
</dl>

</dd>
<dt id="ordered">ordered</dt>
<dd>

<p>If an element is a vtable and this parameter is true, the vtable&#39;s elements will be processed in the order specified by elements&#39; <code>order</code> parameters.</p>

<p>This is useful if elements have callback functions which must be called in a specific order.</p>

<p>To specify the <code>ordered</code> attribute for <i>implicit</i> vtables you must use the <code>ordered</code> validation option. Implicit vtables are created for the specification passed to <b>validate_tbl</b> and for pure named-element specifications passed to <b>validate</b>.</p>

</dd>
<dt id="order">order</dt>
<dd>

<p>If an element is <i>in</i> a vtable and the vtable has <code>ordered</code> set, this specifies the &quot;weight&quot; of the item; elements with smaller weights will be processed before elements with larger weights. <b>Note:</b> if an element specification is generated by a function (see <a href="#Mutating-Validation-Specifications">&quot;Mutating Validation Specifications&quot;</a>) its <code>order</code> parameter is <i>ignored</i>, as the order of validation is determined prior to validation of the elements and mutating functions are called during validation.</p>

</dd>
<dt id="before">before</dt>
<dd>

</dd>
<dt id="after">after</dt>
<dd>

<p>Functions to be called for each element before and after validation. They are called with two arguments: the passed element value, and a table (see <a href="#Callback-Arguments">&quot;Callback Arguments&quot;</a> for its contents). If the function wishes to modify the element value it should return two arguments, <code>true</code> and the new value, else it should return <code>false</code>.</p>

<p>Please note:</p>

<ul>

<li><p>If an error occurs during validation, the <code>after</code> function will not be called.</p>

</li>
<li><p>Specification validation is done before the <code>before</code> function is invoked. If a specification is invalid neither callback is invoked.</p>

</li>
<li><p>The functions are called at the table level for elements which are vtables.</p>

</li>
<li><p>These were previously named <code>precall</code> and <code>postcall</code>. These names are <b>DEPRECATED</b>.</p>

</li>
</ul>

</dd>
<dt id="name">name</dt>
<dd>

<p>A name for a positional element. If specified and the <code>named</code> validation option is <i>true</i>, then the element will be assigned this name in the returned table. See <a href="#Validation-Options">&quot;Validation Options&quot;</a> for more information.</p>

</dd>
<dt id="named">named</dt>
<dd>

<p>Indicate that a name should be (or not be) assigned to a positional element. This option overrides the validation option of the same name, and is useful for control over particular elements.</p>

<p>This option can only be specified for positional elements in tables, not at the top level of the data structure, e.g.</p>

<pre><code>  spec = { { name = &#39;foo&#39;, named = true } }</code></pre>

<p>will cause an error to be thrown, while</p>

<pre><code>  spec = { data = { vtable = { { name = &#39;foo&#39;, named = true } } }}</code></pre>

<p>is legal. Use the <code>named</code> validation option to assign names to top level positional elements.</p>

</dd>
<dt id="multiple">multiple</dt>
<dd>

<p>This indicates that the element is a table whose members must each meet the validation specifications. For example, to validate a list of positive integers:</p>

<pre><code>  { type = &#39;posint&#39;, multiple = true }</code></pre>

<p>This parameter may take the following values:</p>

<dl>

<dt id="true-or-false"><code>true</code> or <code>false</code></dt>
<dd>

<p>If <code>true</code>, each member of the element table is validated.</p>

</dd>
<dt id="a-table-of-options">a table of options</dt>
<dd>

<p>In addition to validating the members of the input table, further validation is possible. The following options are recognized:</p>

<dl>

<dt id="n">n</dt>
<dd>

<p>This specifies the exact number of members in the element table. It is optional.</p>

</dd>
<dt id="min">min</dt>
<dd>

<p>This specifies the required minimum number of members in the element table. It may not be combined with the <b>n</b> option. It is optional.</p>

</dd>
<dt id="max">max</dt>
<dd>

<p>This specifies the required maximum number of members in the element table. It may not be combined with the <b>n</b> option. It is optional.</p>

</dd>
<dt id="keys">keys</dt>
<dd>

<p>This specifies a validation specification for the <i>keys</i> in the element table. It is optional.</p>

<p>For example, the following ensures that keys consist only of alphabetical characters:</p>

<pre><code>  multiple = {
     keys = {
       vfunc = function( val )
                 if type(val) == &#39;string&#39;
                    and val:match( &#39;^%a+$&#39; ) then
                   return true, val
                 else
                   return false,
                          &quot;only alpha characters allowed&quot;
                 end
               end
         }
  }</code></pre>

</dd>
<dt id="allow_scalar">allow_scalar</dt>
<dd>

<p>Normally, indicating a multiplicity implies that the element must be a table. This ensures that there is no confusion if the members of that table are themselves tables For. example, is</p>

<pre><code>  foo = { a = 2 }</code></pre>

<p>a table of multiple values (with multiplicity of 1) or is it a single value which happens to be a table?</p>

<p>If the element is a scalar, there is no confusion. If this option is <b>true</b>, <b>validate.args</b> will upgrade the element to a table.</p>

<p>This option defaults to <b>false</b></p>

</dd>
</dl>

</dd>
</dl>

</dd>
</dl>

<h2 id="Element-Types">Element Types</h2>

<p><b>validate.args</b> supports two schemes for specifying element types for the <code>type</code> option: <i>simple</i> and <i>inline</i>.</p>

<p>Simple types include the standard Lua types and can be augmented using the <b>add_type</b> function or method. They are specified using their name (as a string):</p>

<dl>

<dt id="number">&#39;number&#39;</dt>
<dd>

</dd>
<dt id="string">&#39;string&#39;</dt>
<dd>

</dd>
<dt id="boolean">&#39;boolean&#39;</dt>
<dd>

</dd>
<dt id="table">&#39;table&#39;</dt>
<dd>

</dd>
<dt id="function">&#39;function&#39;</dt>
<dd>

</dd>
<dt id="thread">&#39;thread&#39;</dt>
<dd>

</dd>
<dt id="userdata">&#39;userdata&#39;</dt>
<dd>

<p>These are the built-in types as returned by the Lua <b>type</b> function.</p>

</dd>
<dt id="posnum">&#39;posnum&#39;</dt>
<dd>

<p>The element must be a number greater than zero.</p>

</dd>
<dt id="zposnum">&#39;zposnum&#39;</dt>
<dd>

<p>The element must be a number greater than or equal to zero.</p>

</dd>
<dt id="posint">&#39;posint&#39;</dt>
<dd>

<p>The element must be an integer greater than zero.</p>

</dd>
<dt id="zposint">&#39;zposint&#39;</dt>
<dd>

<p>The element must be an integer greater than or equal to zero.</p>

</dd>
</dl>

<p>Inline types are specified as tables of validation specifications. They are a bit more complex.</p>

<ol>

<li><p>When using inline type specifications, the specifications must be passed to the <code>types</code> option as a <i>list</i> of types, even if there is only one specification.</p>

</li>
<li><p>Inline types must be given a name. It should not be the same as the name of any simple type.</p>

</li>
</ol>

<p>For example, here is the type specification for the <b>multiple</b> option:</p>

<pre><code>     type = { &#39;boolean&#39;,
              [&#39;multiple table&#39;] = {
                 vtable = {
                    min = { type = &#39;zposint&#39;, optional = true,
                            excludes = &#39;n&#39;
                         },
                    max = { type = &#39;posint&#39;,  optional = true,
                            excludes = &#39;n&#39;
                         },
                    n   = { type = &#39;posint&#39;,  optional = true,
                            excludes = { &#39;min&#39;, &#39;max&#39; }
                         },
                    keys   = { vtable = validate_spec,
                               optional = true
                            },
                    allow_scalar = { type = &#39;boolean&#39;, default = false },
                 }
              }
           },</code></pre>

<p>It indicates that <b>multiple</b> may either be a boolean value or a table which may have the elements <code>min</code>, <code>max</code>, c&lt;n&gt;, etc.</p>

<h2 id="Callback-Arguments">Callback Arguments</h2>

<p>Several of the validation specification entries take callback functions. The last argument passed to these functions is a table containing the following named entries:</p>

<dl>

<dt id="va">va</dt>
<dd>

<p>The validation object. In the case that the procedural interface is being used, this will be a default object.</p>

</dd>
<dt id="name1">name</dt>
<dd>

<p>The fully qualified name of the element stored as a <code>validate.args.Name</code> object. Use the <code>tostring()</code> function (or the similarly named method) to stringify it.</p>

</dd>
<dt id="spec">spec</dt>
<dd>

<p>The specification table for the element. <b>Do not modify this</b>.</p>

</dd>
</dl>

<h2 id="Catch-all-Specifications">Catch-all Specifications</h2>

<p>It is possible to provide default specifications for named or positional elements in tables. These are passed as specifications for the special names <code>%named</code> and <code>%pos</code>. A third special name <code>%default</code> is an alternative which can be used to provide a catch-all for all unmatched elements.</p>

<p>The specifications must be functions. They are passed the element name or position and its value.</p>

<p>If the element is <i>acceptable</i>, the function must return a true boolean value and a specification table for the element.</p>

<p>If the element is <i>not acceptable</i>, the function must return a false boolean value. The function may also optionally return an error message (otherwise a generic error message is generated).</p>

<p>For example, to catch all even numbered positional elements in a table after the first two:</p>

<pre><code>    vtable = {
       { name = &quot;first&quot;, type = &#39;string&#39; },
       { name = &quot;second&quot;, type = &#39;table&#39; },
       [%pos] = function (k,v)
                   --only look at even numbered positions
                   if k%2 == 0 then
                     return true, { type = &#39;posint&#39; }
                   else
                     -- ignore odd numbers
                     return false
                   end
                end
    }</code></pre>

<h2 id="Mutating-Validation-Specifications">Mutating Validation Specifications</h2>

<p>A validation specification is usually (as documented above) a table of constraints. In the case where the entire validation table must be created on the fly the validation specification may be a <i>function</i>. The function should take a single parameter - the passed element <i>value</i> - and must return two values:</p>

<ol>

<li><p>a boolean indicating success or failure;</p>

</li>
<li><p>Upon success, a table of validation specifications. Upon failure, an error message.</p>

</li>
</ol>

<h2 id="Element-Groups">Element Groups</h2>

<p>Some operations on groups of elements are possible for named elements. These are specified as special &quot;names&quot; in the validation specification. In order to accomodate multiple groups, these &quot;names&quot; take as values a <i>list of lists</i>,</p>

<pre><code>  [&#39;%one_of&#39;] = { { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; } }</code></pre>

<p><b>not</b> a simple list:</p>

<pre><code>  [&#39;%one_of&#39;] = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; }</code></pre>

<p>This allows specifying multiple groups:</p>

<pre><code>  [&#39;%one_of&#39;] = { { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; } , { &#39;d&#39;, &#39;e&#39;, &#39;f&#39; } }</code></pre>

<dl>

<dt id="one_of1">%one_of</dt>
<dd>

<p>This ensures that exactly one element in a group is specified. For example, say that the caller must provide exactly one of the elements <code>arg1</code>, <code>arg2</code>, or <code>arg3</code>. Exclusivity is obtained via</p>

<pre><code>  arg1 = { optional = true, excludes = { &#39;arg2&#39;, &#39;arg3&#39; } },
  arg2 = { optional = true, excludes = { &#39;arg1&#39;, &#39;arg3&#39; } },
  arg3 = { optional = true, excludes = { &#39;arg1&#39;, &#39;arg2&#39; } }</code></pre>

<p>But that doesn&#39;t force the user to specify any. This addition will:</p>

<pre><code>  [&#39;%one_of&#39;] = {{ &#39;arg1&#39;, &#39;arg2&#39;, &#39;arg3&#39; }}</code></pre>

<p>Note that specifying the <code>excludes</code> attribute is redundant with <code>%one_of</code>, so the above could be rewritten as</p>

<pre><code>  arg1 = { optional = true },
  arg2 = { optional = true },
  arg3 = { optional = true }
  [&#39;%one_of&#39;] = {{ &#39;arg1&#39;, &#39;arg2&#39;, &#39;arg3&#39; }}</code></pre>

</dd>
<dt id="oneplus_of">%oneplus_of</dt>
<dd>

<p>This ensures that at least one element in a group is specified. More may be specified. As a complicated example:</p>

<pre><code>  sigma   = { optional = true, excludes = { &#39;sigma_x&#39;, &#39;sigma_y&#39; } },
  sigma_x = { optional = true, requires = { &#39;sigma_y&#39; } },
  sigma_y = { optional = true, requires = { &#39;sigma_x&#39; } },
  [&#39;%oneplus_of&#39;] = { { &#39;sigma_x&#39;, &#39;sigma_y&#39;, &#39;sigma&#39; } },</code></pre>

<p>ensures that only one of the two following situations occurs:</p>

<pre><code>  sigma
  sigma_x sigma_y</code></pre>

</dd>
</dl>

<h2 id="Validation-Options">Validation Options</h2>

<p>There are a few options which affect the validation process. How they are specifed depends upon whether the procedural or object-oriented interfaces are used; see <a href="#Procedural-interface">&quot;Procedural interface&quot;</a> and <a href="#Object-oriented-interface">&quot;Object oriented interface&quot;</a> for more details.</p>

<dl>

<dt id="before1">before</dt>
<dd>

<p>This specifies a function which is called with the input data prior to any validation. The data are passed as a table, which may be modified. The function should return a boolean indicating success or failure; in the latter case it should also return an error mesage.</p>

</dd>
<dt id="after1">after</dt>
<dd>

<p>This specifies a function which is called with the completely validated data prior to returning to the calling routine. The data are passed as a table, which may be modified. The function should return a boolean indicating success or failure; in the latter case it should also return an error mesage.</p>

</dd>
<dt id="check_spec">check_spec</dt>
<dd>

<p>By default the passed validation specification is not itself checked for consistency, as this may be too much of a performance hit. Setting this to <code>true</code> will cause the specifications to be checked.</p>

<p>This defaults to <code>false</code>.</p>

</dd>
<dt id="error_on_invalid">error_on_invalid</dt>
<dd>

<p>If <code>true</code>, the Lua <b>error()</b> function will be called the case of invalid elements instead of returning a status code and message.</p>

<p>This defaults to <code>false</code>.</p>

</dd>
<dt id="error_on_bad_spec">error_on_bad_spec</dt>
<dd>

<p>If this is <code>true</code>, an invalid validation specification will result in a call to the Lua <b>error()</b> function.</p>

<p>This defaults to <code>false</code>.</p>

</dd>
<dt id="named1">named</dt>
<dd>

<p>If this is <code>true</code>, positional elements are returned as a table, with their names given either by the <code>name</code> attribute in the validation specification or by their cardinal index in the argument list. For example:</p>

<pre><code>   ok, opts = validate_opts( { named = true },
                             { { name = a }, { }, },
                             22, 3
                              )</code></pre>

<p>will result in</p>

<pre><code>   opts.a = 22
   opts[2] = 3</code></pre>

<p>This defaults to <code>false</code>.</p>

</dd>
<dt id="allow_extra">allow_extra</dt>
<dd>

<p>If this is <code>true</code>, then any extra elements (either named or positional) which are not mentioned in the validation specification are quietly ignored. For example:</p>

<pre><code>  local ok, a, b, c = validate_opts( { allow_extra = true,
                                       pass_through = true,
                                      },
                                      { {}, {} },
                                     1, 2, 3)</code></pre>

<p>would result in</p>

<pre><code>  a = 1
  b = 2
  c = nil</code></pre>

<p>This defaults to <code>false</code>.</p>

</dd>
<dt id="pass_through">pass_through</dt>
<dd>

<p>If this is <code>true</code> and <code>allow_extra</code> is also <code>true</code>, then any extra elements (either named or positional) which are not mentioned in the validation specification are passed through. For example:</p>

<pre><code>  local ok, a, b, c = validate_opts( { allow_extra = true,
                                       pass_through = true,
                                      },
                                      { {}, {} },
                                     1, 2, 3)</code></pre>

<p>would result in</p>

<pre><code>  a = 1
  b = 2
  c = 3</code></pre>

<p>This defaults to <code>false</code>.</p>

</dd>
<dt id="udata">udata</dt>
<dd>

<p>This option is used to pass arbitrary data to the callback routines. Use the <code>getopt</code> method to retrieve it.</p>

</dd>
<dt id="ordered1">ordered</dt>
<dd>

<p>If this is true, implicit vtables will be processed in order specified by their elements&#39; <code>order</code> parameters. See the documentation for the <code>ordered</code> validation specification for more information.</p>

</dd>
</dl>

<h2 id="Object-oriented-interface">Object oriented interface</h2>

<h3 id="Constructors">Constructors</h3>

<p>There are two available constructors: a constructor based upon class defaults and one based upon an object:</p>

<dl>

<dt id="Class-constructor">Class constructor</dt>
<dd>

<pre><code>  va = require( &#39;validate.args&#39; )
  vobj = va:new( args )</code></pre>

<p>This constructs a new validation object based upon either the class defaults or the current defaults (as set by the <b>opts()</b> and <b>add_type()</b> functions). It takes a table of named arguments:</p>

<dl>

<dt id="use_current_options">use_current_options</dt>
<dd>

<p>If true, the values of the object&#39;s validation options are taken from the current option values set by the <code>opts()</code> function. If false (the default), the options have the default values specified above.</p>

</dd>
<dt id="use_current_types">use_current_types</dt>
<dd>

<p>If true, the validation types are taken from the current values set by the <code>add_type()</code> function. If false (the default), the options have the default values specified above.</p>

</dd>
<dt id="use_current">use_current</dt>
<dd>

<p>This is equivalent to specifying both <code>use_current_types</code> and <code>use_current_options</code> to the same value.</p>

</dd>
</dl>

</dd>
<dt id="Object-constructor">Object constructor</dt>
<dd>

<pre><code>  -- create and specialize an object
  va = require( &#39;validate.args&#39; )
  vobj = va:new( args )
  vobj:add_type( ... )
  vobj.opts.xxx = yyy

  -- now create an independent copy of it
  nobj = vobj:new()</code></pre>

<p>This creates an independent copy of the <code>vobj</code> object, including all of its options and types. This is useful for nested specialization of types and options.</p>

<p><b>Warning!</b> Only a shallow copy of the objects&#39; validation options is made; if any of the option values are tables (e.g. <code>udata</code>) the options in the new object will refer to the same tables as in the original object.</p>

<p><b>Do not rely upon this behavior.</b></p>

</dd>
</dl>

<h3 id="Methods">Methods</h3>

<dl>

<dt id="setopts">setopts</dt>
<dd>

<pre><code>  vobj:setopts{ opt1 = val1, opt2 = val2 }
  -- or
  vobj.opts.opt1 = val1
  vobj.opts.opt2 = val2</code></pre>

<p>Set the specified validation options (See <a href="#Validation-Options">&quot;Validation Options&quot;</a> for the valid options). These hold for this object only. An error will be thrown if the specified options are not recognized.</p>

</dd>
<dt id="add_type">add_type</dt>
<dd>

<pre><code>   vobj:add_type( type_name, func )</code></pre>

<p>Register a validation function for the named type which will be accepted by the <b>type</b> validation attribute.</p>

<p>The function will be passed the value of the element to validate. It should return two values:</p>

<ol>

<li><p>a boolean indicating success or failure;</p>

</li>
<li><p>the (possibly modified) element value upon success, an error message upon failure</p>

</li>
</ol>

<p>For example, the following</p>

<pre><code>  vobj:add_type( &#39;mytype&#39;, function( arg )
                          if &#39;number&#39; == type(arg) then
                            return true, 3 * arg
                          else
                            return false, &#39;not a number between 2 &amp; 3&#39;
                          end
                      end
          )</code></pre>

<p>adds a new type called <code>mytype</code> which accepts only numbers between 2 and 3 (exclusive) and modifies the element value by multiplying it by 3.</p>

</dd>
<dt id="validate">validate</dt>
<dd>

<pre><code>  vobj:validate( specs, ... )</code></pre>

<p>Validate the passed list against the specifications. It returns a list of values. The first value is a boolean indicating whether or not the validation succeeded.</p>

<p>If validation succeeded, the remainder of the list contains the values (possibly modified during the validation).</p>

<p>If validation failed, the second value is a string indicating what caused the failure.</p>

</dd>
<dt id="validate_tbl">validate_tbl</dt>
<dd>

<pre><code>  vobj:validate_tbl( specs, table )</code></pre>

<p>Validate the contents of the passed table against the specifications. The return values are the same as for <b>validate</b>.</p>

</dd>
<dt id="getopt">getopt</dt>
<dd>

<pre><code>  vobj:getopt( opt )</code></pre>

<p>Returns the value of the specified option. Throws an error if the option does not exist.</p>

</dd>
</dl>

<h2 id="Procedural-interface">Procedural interface</h2>

<dl>

<dt id="validate-specs">validate( specs, ... )</dt>
<dd>

<pre><code>  validate( specs, ... )</code></pre>

<p>Validate the passed list against the specifications using the current global settings for the validation options. See the documentation for the <code>validate()</code> method for more details.</p>

</dd>
<dt id="validate_opts">validate_opts</dt>
<dd>

<pre><code>  validate_opts( opts, specs, ... )</code></pre>

<p>Validate the passed list against the specifications using the current global settings for the validation options. Temporary values for validations options may be specified with the <code>opts</code> argument. The return values are the same as <b>validate</b>.</p>

</dd>
<dt id="validate_tbl1">validate_tbl</dt>
<dd>

<pre><code>  validate_tbl( opts, specs, tble )</code></pre>

<p>Validate the contents of the passed table against the specifications using the current global settings for the validation options. Temporary values for validations options may be specified with the <code>opts</code> argument. The validation workflow may be altered via options passed via the <code>opts</code> argument. The return values are the same as <b>validate</b>.</p>

</dd>
<dt id="add_type1">add_type</dt>
<dd>

<pre><code>  add_type( type_name, func )</code></pre>

<p>Globally register a validation function for the named type which will be accepted by the <b>type</b> validation attribute. See the <code>add_type()</code> method for more details on the arguments.</p>

<p>The function will be passed the value of the element to validate. It should return two values:</p>

</dd>
<dt id="opts-table-of-options">opts( <i>table of options</i> )</dt>
<dd>

<p>Globally set the values for the passed options. See <a href="#Validation-Options">&quot;Validation Options&quot;</a> for the available options.</p>

</dd>
<dt id="posnum-arg">posnum( arg )</dt>
<dd>

<p>Test if <code>arg</code> is a number greater than zero. Returns true upon success, false and and error message if not.</p>

</dd>
<dt id="zposnum-arg">zposnum( arg )</dt>
<dd>

<p>Test if <code>arg</code> is a number greater or equal to zero. Returns true upon success, false and and error message if not.</p>

</dd>
<dt id="posint-arg">posint( arg )</dt>
<dd>

<p>Test if <code>arg</code> is a integer greater than zero. Returns true upon success, false and and error message if not.</p>

</dd>
<dt id="zposint-arg">zposint( arg )</dt>
<dd>

<p>Test if <code>arg</code> is an integer greater or equal to zero. Returns true upon success, false and and error message if not.</p>

</dd>
</dl>

<h1 id="EXAMPLES">EXAMPLES</h1>

<ul>

<li><p>Named parameters, some optional</p>

<pre><code>  function foo( ... )
    local ok, args = validate( { a = { type = &#39;number&#39; },
                                 b = { default  = 22,
                                       type = &#39;number&#39; },
                     }, ... )
  end</code></pre>

<p>If called as</p>

<pre><code>  foo{ a = 12 }</code></pre>

<p>then</p>

<pre><code>  args.a = 12
  args.b = 22</code></pre>

</li>
<li><p>Positional parameters and optional named ones</p>

<pre><code>  function bar( ... )
    local ok, arg1, arg2, opts
                   = validate( { { type = &#39;string&#39; },
                                 { type = &#39;number&#39; },
                                 { vtable = {
                                     a = { default = true,
                                           type = &#39;boolean&#39; },
                                     b = { default = 22,
                                           type = &#39;number&#39; },
                                   },
                                 }
                               }, ... )
  end</code></pre>

<p>If called as</p>

<pre><code>  bar( &#39;a&#39;, &#39;22&#39;, { b = 33 } )</code></pre>

<p>then</p>

<pre><code>  arg1 = &#39;a&#39;
  arg2 = 22
  opts.a = true
  opts.b = 33</code></pre>

</li>
<li><p>vtable functions</p>

<p>In this example a function (<code>foo()</code>) takes a named parameter, <code>idist</code>, which describes a random number distribution and its parameters:</p>

<pre><code>  foo( idist = { &#39;gaussian&#39;, sigma = 33 } );
  foo( idist = { &#39;powerlaw&#39;, alpha = 1.5 } );</code></pre>

<p><code>idist</code> is a table with the name of the distribution as the first positional value and its parameters as subsequent named parameters. Each random number distribution has different parameters, so a simple specification cannot be written which would cover all possible cases. This is where using a vtable function makes it easy.</p>

<p>First, create a table containing validation specifications for each of the distributions. The distribution names are the keys:</p>

<pre><code>  specs = { gaussian = { {}, sigma = { type = &#39;number&#39; } },
            uniform  = { {},  },
            powerlaw = { {}, alpha = { type = &#39;number&#39; } },
          }</code></pre>

<p>The specifications are used to validate the entire contents of idist, so the name of the distribution must be validated as well (hence the <code>{}</code> as the first element in the specification table). Later, in the full validation specification for <code>foo()</code>, <code>idist</code> is validated using a vtable function which selects the correct validation specification based upon the value of the first positional element (the name of the function):</p>

<pre><code>  { idist = { vtable = function (arg)
                          local vtable = specs[arg[1]]
                          if vtable then
                            return true, vtable
                          else
                            return false, &quot;unknown idist: &quot; .. tostring(arg)
                          end
                       end } }</code></pre>

</li>
<li><p>Homogeneous Lists</p>

<p>In this example, an element may be a list of numbers.</p>

<pre><code>  { multiple = true, type = &#39;number&#39; }</code></pre>

</li>
<li><p>Heterogeneous Lists</p>

<p>In this example, an element may be a list of enumerated strings or non-negative integers.</p>

<pre><code>  { multiple = true,
    type = { &#39;zposnum&#39;,
              [&#39;Food Groups&#39;] =
                  { enum = { &#39;Fruit&#39;, &#39;Bread&#39;, &#39;Snacks&#39; } }
            }
  }</code></pre>

</li>
</ul>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Diab Jerius, &lt;djerius@cfa.harvard.edu&gt;</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (C) 2010-2011 by the Smithsonian Astrophysical Observatory</p>

<p>This software is released under the GNU General Public License. You may find a copy at <a href="http://www.fsf.org/copyleft/gpl.html">http://www.fsf.org/copyleft/gpl.html</a>.</p>


</body>

</html>


