.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.15)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "validate.args l"
.TH validate.args l "2011-05-13" " " " "
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
validate.args \- validate arguments
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  va = require(\*(Aqvalidate.args\*(Aq)
\&
\&  \-\- foo( a, b )
\&  func foo( ... )
\&    local spec = { <specifications> }
\&    local ok, a, b = va.validate( spec, ... )
\&  end
\&
\&  \-\-\- goo( c, d )
\&  func goo( ... )
\&    local spec = { <specifications> }
\&    local ok, c, d = va.validate( options, spec, ... )
\&  end
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBvalidate.args\fR validates that a function's arguments meet certain
specifications.  Both scalar and table arguments are validated, and
validation of nested tables is supported.  \fBvalidate.args\fR provides
two main validation functions, \f(CW\*(C`validate()\*(C'\fR and \f(CW\*(C`validate_opts()\*(C'\fR.
They differ in that \f(CW\*(C`validate()\*(C'\fR uses global settings for options
which control the validation process while \f(CW\*(C`validat_opts()\*(C'\fR
allows setting those options for a specific validation.
.PP
Positional, named, and mixed positional and named arguments are
supported.  Positional arguments may be converted to named arguments
for uniformity of access (see \*(L"Validation Options\*(R").  Each argument
has a validation specification which provides the validation
constraints.
.IP "Positional arguments" 4
.IX Item "Positional arguments"
.Vb 1
\&  foo( 3, \*(Aqn\*(Aq )
.Ve
.Sp
Positional arguments are not explicitly named when passed to the
function.  Their validation specifications are passed as a list,
one element per argument:
.Sp
.Vb 3
\&  { { pos1 specification },
\&    { pos2 specification }
\&  }
.Ve
.IP "Named arguments" 4
.IX Item "Named arguments"
.Vb 1
\&  goo{ a = 3, b = \*(Aqn\*(Aq }
.Ve
.Sp
Named arguments are passed as a single table to the function (notice
the use of the \f(CW\*(C`{}\*(C'\fR syntactic sugar in the function invocation).  Their validation
specifications are passed as a table:
.Sp
.Vb 3
\& { arg1_name = { arg1 specification },
\&   arg2_name = { arg2 specification }
\& }
.Ve
.ie n .IP """mixed"" mode" 4
.el .IP "``mixed'' mode" 4
.IX Item "mixed mode"
.Vb 1
\&  bar( 3, \*(Aqn\*(Aq, { c = 22 } )
.Ve
.Sp
Here a nested table is used to hold the named arguments. The table is
simply another positional argument, so the validation specifications
are passed as a list, one per argument:
.Sp
.Vb 4
\&  { { pos1 specification },
\&    { pos2 specification },
\&    { table specification }
\&  }
.Ve
.Sp
The validation specification for the table specifies the constraints
on the named arguments, typically using the \f(CW\*(C`vtable\*(C'\fR constraint.
.SS "Validation Specifications"
.IX Subsection "Validation Specifications"
A validation specification is a set of constraints which an argument
must meet.  In most cases the specification is encoded in a table, where each
key-value pair represents a type of constraint and its
parameters.   The specification may also be specified by a function; see \*(L"Mutating
Validation Specifications\*(R".
.PP
Multiple constraints may be specified for each argument. There are no
guarantees as to the order in which the constraints are applied.
.PP
The caller may provide constraints which modify the passed arguments;
these must not expect a particular sequence of operation.
.PP
The following constraint types are recognized:
.IP "optional" 4
.IX Item "optional"
This is a boolean attribute which, if true, indicates that the argument
need not be present.  Positional as well as named arguments may be
optional; if they are not at the end of the list they may be specified
as \f(CW\*(C`nil\*(C'\fR in the function call, e.g.
.Sp
.Vb 1
\&  foo( nil, 3 )
.Ve
.Sp
It defaults to \f(CW\*(C`false\*(C'\fR.  All arguments are required by default.
.IP "default" 4
.IX Item "default"
This provides a value for the argument if it is not specified, as
well as indicating that the argument is optional.  This may be a function,
which will be called if a default value is required.  The function
should return two values:
.RS 4
.IP "1." 4
a boolean indicating success or failure;
.IP "2." 4
the default value upon success, an error message upon failure
.RE
.RS 4
.RE
.IP "type" 4
.IX Item "type"
This specifies the expected type of argument. It may be either a single
type or a list of types:
.Sp
.Vb 2
\&  type = \*(Aqnumber\*(Aq
\&  type = { \*(Aqnumber\*(Aq, \*(Aqboolean\*(Aq }
.Ve
.Sp
Types are specified as strings, with the following types available:
.RS 4
.IP "'nil'" 4
.IX Item "'nil'"
.PD 0
.IP "'number'" 4
.IX Item "'number'"
.IP "'string'" 4
.IX Item "'string'"
.IP "'boolean'" 4
.IX Item "'boolean'"
.IP "'table'" 4
.IX Item "'table'"
.IP "'function'" 4
.IX Item "'function'"
.IP "'thread'" 4
.IX Item "'thread'"
.IP "'userdata'" 4
.IX Item "'userdata'"
.PD
These are the built-in types as returned by the Lua \fBtype\fR function.
.IP "'posnum'" 4
.IX Item "'posnum'"
The argument must be a number greater than zero.
.IP "'zposnum'" 4
.IX Item "'zposnum'"
The argument must be a number greater than or equal to zero.
.IP "'posint'" 4
.IX Item "'posint'"
The argument must be an integer greater than zero.
.IP "'zposint'" 4
.IX Item "'zposint'"
The argument must be an integer greater than or equal to zero.
.RE
.RS 4
.Sp
To add additional types see the \fBadd_type\fR function.
.RE
.IP "enum" 4
.IX Item "enum"
This specifies one or more explicit values which the argument may
take. It may be either a single value or a list of values:
.Sp
.Vb 2
\&  enum = 33
\&  enum = { \*(Aqa\*(Aq, 33, \*(Aqb\*(Aq }
.Ve
.IP "not_nil" 4
.IX Item "not_nil"
This is a boolean and indicates that the value must not be nil.  This
only pertains to positional arguments.
.IP "requires" 4
.IX Item "requires"
This lists the names of one or more arguments which \fImust\fR be specified
in addition to the current argument.  The value is either a single
name or a list of names:
.Sp
.Vb 2
\&  requires = \*(Aqarg3\*(Aq
\&  requires = { \*(Aqarg3\*(Aq, \*(Aqarg4\*(Aq }
.Ve
.Sp
See also \*(L"Argument Groups\*(R"
.IP "excludes" 4
.IX Item "excludes"
This lists the names of one or more arguments which \fImay not\fR be specified
in addition to the current argument.  The value is either a single
name or a list of names:
.Sp
.Vb 2
\&  excludes = \*(Aqarg3\*(Aq
\&  excludes = { \*(Aqarg3\*(Aq, \*(Aqarg4\*(Aq }
.Ve
.Sp
See also \*(L"Argument Groups\*(R"
.IP "one_of" 4
.IX Item "one_of"
This provides a list of names of other arguments of which exactly
one \fImust\fR be specified in addition to the current argument:
.Sp
.Vb 1
\&  one_of = { \*(Aqarg3\*(Aq, \*(Aqarg4\*(Aq }
.Ve
.Sp
See also \*(L"Argument Groups\*(R"
.IP "vfunc" 4
.IX Item "vfunc"
This specifies a function which is called to validate the argument.
It is called with a single argument, the passed argument
value. It must return two values:
.RS 4
.IP "1." 4
a boolean indicating success or failure;
.IP "2." 4
the (possibly modified) argument value upon success, an error message upon failure
.RE
.RS 4
.Sp
For example,
.Sp
.Vb 6
\&  vfunc = function( orig )
\&            if type(orig) == \*(Aqnumber\*(Aq and orig >= 3 then
\&              return true, orig / 22
\&            end
\&              return false, \*(Aqnot a number or less then 3\*(Aq
\&          end
.Ve
.RE
.IP "vtable" 4
.IX Item "vtable"
This is used to validate the contents of an argument which is a table.
It's value may be either:
.RS 4
.IP "a table of specifications" 4
.IX Item "a table of specifications"
There should be one element in the specification table for each element
in the argument table. For example, to validate a call such as
.Sp
.Vb 1
\&  foo( \*(Aqhello\*(Aq, { nv1 = 3, nv2 = 2 } )
.Ve
.Sp
Use
.Sp
.Vb 7
\&  spec = { { type = \*(Aqstring\*(Aq },
\&           { vtable = { nv1 = { type = \*(Aqposint\*(Aq },
\&                        nv2 = { type = \*(Aqint\*(Aq },
\&                      }
\&           }
\&         }
\&  ok, pos, tbl = validate( spec, ... )
.Ve
.Sp
which will return
.Sp
.Vb 2
\&   pos = \*(Aqhello\*(Aq
\&   tbl = { nv1 = 3, nv2 = 2 }
\&
\& in the above invocation.
.Ve
.IP "a function" 4
.IX Item "a function"
The function should take a single parameter \- the passed argument
\&\fIvalue\fR \- and must return two values:
.RS 4
.IP "1." 4
a boolean indicating success or failure;
.IP "2." 4
Upon success, a table of validation specifcations. Upon failure, an error message.
See \*(L"Examples\*(R" for an example of this in use.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "name" 4
.IX Item "name"
A name for a positional argument.  If specified and the \f(CW\*(C`named\*(C'\fR
validation option is \fItrue\fR, then the argument will be assigned this
name in the returned argument table.  See \*(L"Validation Options\*(R" for
more information.
.SS "Mutating Validation Specifications"
.IX Subsection "Mutating Validation Specifications"
A validation specification is usually (as documented above) a table of
constraints.  In the case where the entire validation table must be
created on the fly the validation specification may be a \fIfunction\fR.
The function should take a single parameter \- the passed argument
\&\fIvalue\fR \- and must return two values:
.IP "1." 4
a boolean indicating success or failure;
.IP "2." 4
Upon success, a table of validation specifcations. Upon failure, an error message.
.SS "Groups of Arguments"
.IX Subsection "Groups of Arguments"
Some operations on groups of arguments are possible for named
arguments.  These are specified as special \*(L"arguments\*(R" in the
validation specification.  In order to accomodate multiple groups,
these \*(L"arguments\*(R" take as values a \fIlist of lists\fR,
.PP
.Vb 1
\&  [\*(Aq%one_of\*(Aq] = { { \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq } }
.Ve
.PP
\&\fBnot\fR a simple list:
.PP
.Vb 1
\&  [\*(Aq%one_of\*(Aq] = { \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq }
.Ve
.PP
in ordeThis allows specifying multiple groups:
.PP
.Vb 1
\&  [\*(Aq%one_of\*(Aq] = { { \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq } , { \*(Aqd\*(Aq, \*(Aqe\*(Aq, \*(Aqf\*(Aq } }
.Ve
.ie n .IP "%one_of" 4
.el .IP "\f(CW%one_of\fR" 4
.IX Item "%one_of"
This ensures that exactly one argument in a group is specified.  For
example, say that the caller must provide exactly one of the arguments
\&\f(CW\*(C`arg1\*(C'\fR, \f(CW\*(C`arg2\*(C'\fR, or \f(CW\*(C`arg3\*(C'\fR.  Exclusivity is obtained via
.Sp
.Vb 3
\&  arg1 = { optional = true, excludes = { \*(Aqarg2\*(Aq, \*(Aqarg3\*(Aq } },
\&  arg2 = { optional = true, excludes = { \*(Aqarg1\*(Aq, \*(Aqarg3\*(Aq } },
\&  arg3 = { optional = true, excludes = { \*(Aqarg1\*(Aq, \*(Aqarg2\*(Aq } }
.Ve
.Sp
But that doesn't force the user to specify any.  This addition will:
.Sp
.Vb 1
\&  [\*(Aq%one_of\*(Aq] = {{ \*(Aqarg1\*(Aq, \*(Aqarg2\*(Aq, \*(Aqarg3\*(Aq }}
.Ve
.Sp
Note that specifying the \f(CW\*(C`excludes\*(C'\fR attribute is redundant with \f(CW%one_of\fR,
so the above could be rewritten as
.Sp
.Vb 4
\&  arg1 = { optional = true },
\&  arg2 = { optional = true },
\&  arg3 = { optional = true }
\&  [\*(Aq%one_of\*(Aq] = {{ \*(Aqarg1\*(Aq, \*(Aqarg2\*(Aq, \*(Aqarg3\*(Aq }}
.Ve
.ie n .IP "%oneplus_of" 4
.el .IP "\f(CW%oneplus_of\fR" 4
.IX Item "%oneplus_of"
This ensures that at least one argument in a group is specified. More
may be specified.  As a complicated example:
.Sp
.Vb 4
\&  sigma   = { optional = true, excludes = { \*(Aqsigma_x\*(Aq, \*(Aqsigma_y\*(Aq } },
\&  sigma_x = { optional = true, requires = { \*(Aqsigma_y\*(Aq } },
\&  sigma_y = { optional = true, requires = { \*(Aqsigma_x\*(Aq } },
\&  [\*(Aq%oneplus_of\*(Aq] = { { \*(Aqsigma_x\*(Aq, \*(Aqsigma_y\*(Aq, \*(Aqsigma\*(Aq } },
.Ve
.Sp
ensures that only one of the two following situations occurs:
.Sp
.Vb 2
\&  sigma
\&  sigma_x sigma_y
.Ve
.SS "Validation Options"
.IX Subsection "Validation Options"
There are a few options which affect the validation process.  These
may be set for individual validations using \fB\f(BIvalidate_opts()\fB\fR, or may
be set globally for validations done via \fB\f(BIvalidate()\fB\fR using
\&\fB\f(BIopts()\fB\fR.
.IP "check_spec" 4
.IX Item "check_spec"
By default the passed validation specification is not itself checked
for consistency, as this may be too much of a performance hit.  Setting
this to \f(CW\*(C`true\*(C'\fR will cause the specifications to be checked.
.Sp
This defaults to \f(CW\*(C`false\*(C'\fR.
.IP "error_on_invalid" 4
.IX Item "error_on_invalid"
If \f(CW\*(C`true\*(C'\fR, the Lua \fB\f(BIerror()\fB\fR function will be called the case of
invalid arguments instead of returning a status code and message.
.Sp
This defaults to \f(CW\*(C`false\*(C'\fR.
.IP "error_on_bad_spec" 4
.IX Item "error_on_bad_spec"
If this is \f(CW\*(C`true\*(C'\fR, an invalid validation specification will result in a
call to the Lua \fB\f(BIerror()\fB\fR function.
.Sp
This defaults to \f(CW\*(C`false\*(C'\fR.
.IP "named" 4
.IX Item "named"
If this is \f(CW\*(C`true\*(C'\fR, positional arguments are returned as a table, with
their names given either by the \f(CW\*(C`name\*(C'\fR attribute in the validation
specification or by their cardinal index in the argument list.
For example:
.Sp
.Vb 4
\&   ok, opts = validate_opts( { named = true },
\&                             { { name = a }, { }, },
\&                             22, 3
\&                              )
.Ve
.Sp
will result in
.Sp
.Vb 2
\&   opts.a = 22
\&   opts[2] = 3
.Ve
.Sp
This defaults to \f(CW\*(C`false\*(C'\fR.
.IP "allow_extra" 4
.IX Item "allow_extra"
If this is \f(CW\*(C`true\*(C'\fR, then any extra arguments (either named or positional)
which are not mentioned in the validation specification are quietly
ignored. For example:
.Sp
.Vb 5
\&  local ok, a, b, c = validate_opts( { allow_extra = true,
\&                                       pass_through = true,
\&                                      },
\&                                      { {}, {} },
\&                                     1, 2, 3)
.Ve
.Sp
would result in
.Sp
.Vb 3
\&  a = 1
\&  b = 2
\&  c = nil
.Ve
.Sp
This defaults to \f(CW\*(C`false\*(C'\fR.
.IP "pass_through" 4
.IX Item "pass_through"
If this is \f(CW\*(C`true\*(C'\fR and \f(CW\*(C`allow_extra\*(C'\fR is also \f(CW\*(C`true\*(C'\fR, then any extra
arguments (either named or positional) which are not mentioned in the
validation specification are passed through.  For example:
.Sp
.Vb 5
\&  local ok, a, b, c = validate_opts( { allow_extra = true,
\&                                       pass_through = true,
\&                                      },
\&                                      { {}, {} },
\&                                     1, 2, 3)
.Ve
.Sp
would result in
.Sp
.Vb 3
\&  a = 1
\&  b = 2
\&  c = 3
.Ve
.Sp
This defaults to \f(CW\*(C`false\*(C'\fR.
.IP "baseOptions" 4
.IX Item "baseOptions"
This option is useful only for the validation functions which take an
options table (such as \fIvalidate_opts()\fR). If \f(CW\*(C`true\*(C'\fR, any options which
are not specified in the options table will be set from the global
options table as modified by the \fB\f(BIopts()\fB\fR function.  Normally they
are set from the default options values.
.Sp
This defaults to \f(CW\*(C`false\*(C'\fR.
.SS "Functions"
.IX Subsection "Functions"
.IP "validate( specs, ... )" 4
.IX Item "validate( specs, ... )"
Validate the passed argument list against the specifications.  It
returns a list of values.  The first value is a boolean indicating
whether or not the validation succeeded.
.Sp
If validation succeeded, the remainder of the list contains the
values of the arguments (possibly modified during the validation).
.Sp
If validation failed, the second value is a string indicating what
caused the failure.
.IP "validate_opts( opts, specs, ... )" 4
.IX Item "validate_opts( opts, specs, ... )"
Validate the passed argument list against the specifications.  The
validation workflow may be altered via options passed via the \f(CW\*(C`opts\*(C'\fR
argument.  The return arguments are the same as \fBvalidate\fR.
.Sp
Those options which are not set in \f(CW\*(C`opts\*(C'\fR are set to the default
values.  If instead they should be set to the values which were
specified by the \fB\f(BIopts()\fB\fR function, set the special option
\&\f(CW\*(C`baseOptions\*(C'\fR to \f(CW\*(C`true\*(C'\fR.
.IP "validate_tbl( opts, specs, tble )" 4
.IX Item "validate_tbl( opts, specs, tble )"
Validate the contents of the passed table against the specifications.
The validation workflow may be altered via options passed via the
\&\f(CW\*(C`opts\*(C'\fR argument.  The return arguments are the same as \fBvalidate\fR.
.Sp
Those options which are not set in \f(CW\*(C`opts\*(C'\fR are set to the default
values.  If instead they should be set to the values which were
specified by the \fB\f(BIopts()\fB\fR function, set the special option
\&\f(CW\*(C`baseOptions\*(C'\fR to \f(CW\*(C`true\*(C'\fR.
.IP "add_type( type_name, func )" 4
.IX Item "add_type( type_name, func )"
Register a validation function for the named type which
will be accepted by the \fBtype\fR validation attribute.
.Sp
The function will be passed the argument to validate.  It should return a
list of values.  The first value is a boolean indicating whether or
not the validation succeeded.
.Sp
Upon success it should return the (possibly modified) argument as the second value.
.Sp
For example, the following
.Sp
.Vb 5
\&  add_type( \*(Aqmytype\*(Aq, function( arg )
\&                          return \*(Aqnumber\*(Aq == type(arg) and  arg > 2 and arg < 3,
\&                                 3 * arg
\&                           end
\&          )
.Ve
.Sp
adds a new type called \f(CW\*(C`mytype\*(C'\fR which accepts only numbers between 2 and 3 (exclusive)
and modifies the argument by multiplying it by 3.
.IP "opts( \fItable of options\fR )" 4
.IX Item "opts( table of options )"
Set the default values for the passed options.  See \*(L"Validation
Options\*(R" for the available options.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "\(bu" 4
Named parameters, some optional
.Sp
.Vb 6
\&  function foo( ... )
\&    local ok, args = validate( { a = { type = \*(Aqnumber\*(Aq },
\&                                 b = { default  = 22,
\&                                       type = \*(Aqnumber\*(Aq },
\&                     }, ... )
\&  end
.Ve
.Sp
If called as
.Sp
.Vb 1
\&  foo{ a = 12 }
.Ve
.Sp
then
.Sp
.Vb 2
\&  args.a = 12
\&  args.b = 22
.Ve
.IP "\(bu" 4
Positional parameters and optional named ones
.Sp
.Vb 10
\&  function bar( ... )
\&    local ok, arg1, arg2, opts
\&                   = validate( { { type = \*(Aqstring\*(Aq },
\&                                 { type = \*(Aqnumber\*(Aq },
\&                                 { vtable = {
\&                                     a = { default = true,
\&                                           type = \*(Aqboolean\*(Aq },
\&                                     b = { default = 22,
\&                                           type = \*(Aqnumber\*(Aq },
\&                                   },
\&                                 }
\&                               }, ... )
\&  end
.Ve
.Sp
If called as
.Sp
.Vb 1
\&  bar( \*(Aqa\*(Aq, \*(Aq22\*(Aq, { b = 33 } )
.Ve
.Sp
then
.Sp
.Vb 4
\&  arg1 = \*(Aqa\*(Aq
\&  arg2 = 22
\&  opts.a = true
\&  opts.b = 33
.Ve
.IP "\(bu" 4
vtable functions
.Sp
In this example a function (\f(CW\*(C`foo()\*(C'\fR) takes a named parameter, \f(CW\*(C`idist\*(C'\fR, which
describes a random number distribution and its parameters:
.Sp
.Vb 2
\&  foo( idist = { \*(Aqgaussian\*(Aq, sigma = 33 } );
\&  foo( idist = { \*(Aqpowerlaw\*(Aq, alpha = 1.5 } );
.Ve
.Sp
\&\f(CW\*(C`idist\*(C'\fR is a table with the name of the distribution as the first
positional value and its parameters as subsequent named parameters.
Each random number distribution has different parameters, so a simple
specification cannot be written which would cover all possible cases.
This is where using a vtable function makes it easy.
.Sp
First, create a table containing validation specifications for each
of the distributions.  The distribution names are the keys:
.Sp
.Vb 4
\&  specs = { gaussian = { {}, sigma = { type = \*(Aqnumber\*(Aq } },
\&            uniform  = { {},  },
\&            powerlaw = { {}, alpha = { type = \*(Aqnumber\*(Aq } },
\&          }
.Ve
.Sp
The specifications are used to validate the entire contents of idist,
so the name of the distribution must be validated as well (hence the
\&\f(CW\*(C`{}\*(C'\fR as the first element in the specification table).  Later, in the
full validation specification for \f(CW\*(C`foo()\*(C'\fR, \f(CW\*(C`idist\*(C'\fR is validated
using a vtable function which selects the correct validation
specification based upon the value of the first positional element
(the name of the function):
.Sp
.Vb 8
\&  { idist = { vtable = function (arg)
\&                          local vtable = specs[arg[1]]
\&                          if vtable then
\&                            return true, vtable
\&                          else
\&                            return false, "unknown idist: " .. tostring(arg)
\&                          end
\&                       end } }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Diab Jerius, <djerius@cfa.harvard.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by the Smithsonian Astrophysical Observatory
.PP
This software is released under the \s-1GNU\s0 General Public License.
You may find a copy at <http://www.fsf.org/copyleft/gpl.html>.
